# Assignment 3: Advanced Database Operations

Building upon the work done in Assignment 2, this assignment involves mocking additional data, creating a view to show a list of products purchased by customers, and developing a function to calculate revenue by cashier. This guide will provide clear, detailed instructions for each task.

## Mock Data

To extend our database with more realistic data, we will add new tables for `customer` and `product`, mock data for these tables, and extend the existing `invoice` and `invoice_detail` tables to include references to these new entities.

### 1. Create New Tables

#### Customer Table

The `customer` table will store information about each customer.

```sql
CREATE TABLE customer (
    customer_id UUID PRIMARY KEY,
    customer_name VARCHAR(255) NOT NULL
);
```

- **`customer_id`**: A unique identifier for each customer using `UUID`.
- **`customer_name`**: The name of the customer.

#### Product Table

The `product` table will store information about each product.

```sql
CREATE TABLE product (
    product_id UUID PRIMARY KEY,
    product_name VARCHAR(255) NOT NULL
);
```

- **`product_id`**: A unique identifier for each product using `UUID`.
- **`product_name`**: The name of the product.

### 2. Modify Existing Tables

#### Modify Invoice Detail Table

Add a foreign key reference to the `product` table.

```sql
ALTER TABLE invoice_detail
ADD COLUMN product_id UUID REFERENCES product(product_id);
```

- **`product_id`**: A foreign key referencing the `product` table.

### 3. Insert Mock Data

#### Insert Customer Data

```sql
INSERT INTO customer (customer_id, customer_name)
VALUES 
    ('550e8400-e29b-41d4-a716-446655440001', 'John Doe'),
    ('550e8400-e29b-41d4-a716-446655440002', 'Jane Smith');
```

- Adds two customers with unique `UUID` identifiers and names.

#### Insert Product Data

```sql
INSERT INTO product (product_id, product_name)
VALUES 
    ('550e8400-e29b-41d4-a716-446655440003', 'Product A'),
    ('550e8400-e29b-41d4-a716-446655440004', 'Product B');
```

- Adds two products with unique `UUID` identifiers and names.

#### Insert Invoice and Invoice Detail Data

We will insert invoices and invoice details that link to the new customer and product data.

```sql
INSERT INTO invoice (invoice_id, customer_id, invoice_date)
VALUES 
    ('550e8400-e29b-41d4-a716-446655440000', '550e8400-e29b-41d4-a716-446655440001', '2024-06-25'),
    ('550e8400-e29b-41d4-a716-446655440002', '550e8400-e29b-41d4-a716-446655440002', '2024-06-26');

INSERT INTO invoice_detail (invoice_detail_id, invoice_id, product_id, item_description, quantity, unit_price)
VALUES 
    ('550e8400-e29b-41d4-a716-446655440004', '550e8400-e29b-41d4-a716-446655440000', '550e8400-e29b-41d4-a716-446655440003', 'Product A', 2, 100.00),
    ('550e8400-e29b-41d4-a716-446655440005', '550e8400-e29b-41d4-a716-446655440000', '550e8400-e29b-41d4-a716-446655440004', 'Product B', 3, 50.00),
    ('550e8400-e29b-41d4-a716-446655440006', '550e8400-e29b-41d4-a716-446655440002', '550e8400-e29b-41d4-a716-446655440003', 'Product A', 1, 100.00);
```

- Links invoice details to products and customers through `UUID` references.

## Create View

We need to create a view that shows a list of products purchased by customers, including details like `customer_id`, `customer_name`, `product_id`, `product_name`, `quantity`, `amount`, and `created_date`.

```sql
CREATE VIEW customer_products_view AS
SELECT
    c.customer_id,
    c.customer_name,
    p.product_id,
    p.product_name,
    d.quantity,
    d.amount,
    i.invoice_date AS created_date
FROM
    customer c
JOIN
    invoice i ON c.customer_id = i.customer_id
JOIN
    invoice_detail d ON i.invoice_id = d.invoice_id
JOIN
    product p ON d.product_id = p.product_id;
```

- This view joins the `customer`, `invoice`, `invoice_detail`, and `product` tables to display relevant information about the purchases.

### Query the View

```sql
SELECT * FROM customer_products_view;
```

- This query retrieves all records from the `customer_products_view`.

## Create Function

We will create a function to calculate the revenue generated by a specific cashier. The input is `cashier_id`.

### Assumptions

For this function, we assume there is a `cashier` table and a `cashier_id` in the `invoice` table.

#### Create Cashier Table

```sql
CREATE TABLE cashier (
    cashier_id UUID PRIMARY KEY,
    cashier_name VARCHAR(255) NOT NULL
);
```

- Adds a `cashier` table with `UUID` as primary key and a name.

#### Modify Invoice Table to Include Cashier

```sql
ALTER TABLE invoice
ADD COLUMN cashier_id UUID REFERENCES cashier(cashier_id);
```

- Adds a `cashier_id` foreign key to the `invoice` table.

### Function Definition

```sql
CREATE FUNCTION calculate_revenue_by_cashier(cashier_id UUID)
RETURNS DECIMAL(10, 2) AS $$
DECLARE
    total_revenue DECIMAL(10, 2);
BEGIN
    SELECT SUM(i.amount) INTO total_revenue
    FROM invoice i
    WHERE i.cashier_id = cashier_id;
    
    RETURN COALESCE(total_revenue, 0.00);
END;
$$ LANGUAGE plpgsql;
```

- **`DECLARE total_revenue`**: A variable to hold the calculated total revenue.
- **`SUM(i.amount)`**: Calculates the sum of `amount` for all invoices associated with the given `cashier_id`.
- **`COALESCE(total_revenue, 0.00)`**: Ensures the function returns `0.00` if no records are found.

### Use the Function

```sql
SELECT calculate_revenue_by_cashier('550e8400-e29b-41d4-a716-446655440007');
```

- This calls the function with a specific `cashier_id` and returns the total revenue generated by that cashier.

## Summary

### Key Points

1. **Mock Data**: We extended our data model to include `customer` and `product` tables and inserted realistic data.
2. **View Creation**: A view was created to show detailed information about customer purchases, integrating data from multiple tables.
3. **Function Creation**: A function was developed to calculate the revenue generated by a specific cashier, demonstrating advanced SQL capabilities.




#
## Compare restful api best practice with your Assignment 2 – lecture 5​

## 1. Accept and Respond with JSON

**Best Practice**: REST APIs should accept JSON for request payloads and respond with JSON. The `Content-Type` header should be set to `application/json`.

**My Implementation**: My Spring Boot controller implicitly handles JSON requests and responses because of the use of `@RestController` and appropriate request/response mappings. This adheres to best practices.

## 2. Use Nouns Instead of Verbs in Endpoint Paths

**Best Practice**: Endpoint paths should use nouns to represent resources and not verbs, as HTTP methods (GET, POST, PUT, DELETE) already define the actions.

**My Implementation**: My endpoint paths (`/employee/all`, `/employee/find/{employeeID}`, `/employee/add`, etc.) mostly follow this convention. However, `/employee/find/{employeeID}` could be simplified to `/employee/{employeeID}` for consistency.

## 3. Name Collections with Plural Nouns

**Best Practice**: Collections of resources should be named with plural nouns.

**My Implementation**: My endpoints (`/employee`, `/employee/{employeeID}`) use singular nouns. Changing `/employee` to `/employees` would better indicate that the endpoint deals with a collection of employee resources.

## 4. Nesting Resources for Hierarchical Objects

**Best Practice**: Nest resources for hierarchical relationships. For example, if departments can have employees, use `/departments/{departmentId}/employees`.

**My Implementation**: I have a department-related endpoint (`/employee/{department}`). This should ideally be nested to reflect the relationship more clearly, like `/departments/{department}/employees`.

## 5. Handle Errors Gracefully and Return Standard Error Codes

**Best Practice**: Use appropriate HTTP status codes to indicate the result of operations and handle errors gracefully.

**My Implementation**: I handle errors and return status codes appropriately. For example, I return `HttpStatus.NOT_FOUND` if an employee is not found. This aligns well with best practices.

## 6. Allow Filtering, Sorting, and Pagination

**Best Practice**: Allow clients to filter, sort, and paginate resources to handle large datasets efficiently.

**My Implementation**: My API does not currently support filtering, sorting, or pagination. Consider adding query parameters to allow for these functionalities, such as `/employees?department={department}&sort=lastName&limit=10&page=2`.

## 7. Maintain Good Security Practices

**Best Practice**: Ensure secure communication (e.g., using SSL/TLS), and implement authentication and authorization to restrict access based on roles.

**My Implementation**: Security aspects are not evident from the provided code. Ensure that my application uses HTTPS and incorporates proper authentication and authorization mechanisms.

## 8. Cache Data to Improve Performance

**Best Practice**: Implement caching to improve performance by reducing the need to query the database repeatedly.

**My Implementation**: Caching is not shown in my code. Consider adding caching mechanisms, such as using Spring Cache or integrating with caching solutions like Redis, to enhance performance.

## 9. Versioning Your APIs

**Best Practice**: Version your APIs to avoid breaking changes for existing clients.

**My Implementation**: API versioning is not visible in my code. We can version our API by adding version numbers to your endpoint paths, like `/v1/employees`.
